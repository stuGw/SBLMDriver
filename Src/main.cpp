/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f030x6.h"
#include "button.h"
#include "init.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define COUNT_SPEEDS 8

Button b;
Button b2;

int speedValues[COUNT_SPEEDS] = { 0,100,200,300,400,500,600,700 };
void SysTick_Handler()
{

	static uint32_t milliseconds = 0;

	milliseconds++;
	b.timeIncrease();
	//GPIOA->BSRR |= 0x0010;
	//GPIOA->BSRR |= 0x0010;
	//bDn.timeIncrease();
	/*if((milliseconds%200) == 0)
	{
		flagButt = 1;
	}*/
}

void EXTI0_1_IRQHandler()
{
	/*if(EXTI->RPR1 & 0x0001){ EXTI->RPR1 |= 0x0001; bUp.rise();  LOG->DEBG("BUP rise"); }
	if(EXTI->RPR1 & 0x0002){ EXTI->RPR1 |= 0x0002; bDn.rise();  LOG->DEBG("BDN rise"); }
	if(EXTI->FPR1 & 0x0001){ EXTI->FPR1 |= 0x0001; bUp.fall();  LOG->DEBG("BUP fall"); }
	if(EXTI->FPR1 & 0x0002){ EXTI->FPR1 |= 0x0002; bDn.fall();  LOG->DEBG("BDN fall"); }*/
	if(EXTI->PR & 0x02)
	{
		if(b.isDown())b.fall(); else b.rise();
		//GPIOA->BSRR |= 0x0010;
		EXTI->PR |= 0x02;
	}

	if(EXTI->PR & 0x01)
	{
		if(b2.isDown())b2.fall(); else b2.rise();
		//GPIOA->BSRR |= 0x0010;
		EXTI->PR |= 0x01;
	}


}




int main(void)
{
	static int j = 0;


	GPIOA->MODER |= 0x00000100;


b.init(&(GPIOA->IDR), GPIOPIN_1, 700, 530);
b2.init(&(GPIOA->IDR), GPIOPIN_0, 700, 530);
startTimer1();

	NVIC_EnableIRQ(SysTick_IRQn);
	NVIC_EnableIRQ(EXTI0_1_IRQn);
	enable_interrupts();
//	GPIOB->MODER
	/* Loop forever */
	for(;;)
		{
			static int i = 0;
			uint8_t bState = b.getState();
			uint8_t bState2 = b2.getState();
if(bState)
{
	j++;
	if(j>=COUNT_SPEEDS) j = COUNT_SPEEDS-1;
	TIM1->PSC = speedValues[j]*10;
	GPIOA->BSRR |= 0x0010;
}

if(bState2)
{
	j--;
	if(j<=0) j = 0;
	TIM1->PSC = speedValues[j]*10;
	GPIOA->BRR |= 0x0010;
}
			if(i == 480000*2)
			{
				if(GPIOA->ODR &0x0010)
				{
				//	GPIOA->BRR |= 0x0010;
				}
				//else
			//		GPIOA->BSRR |= 0x0010;

				i = 0;
			}
			i++;
		}


}
